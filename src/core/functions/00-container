#!/command/with-contenv bash

# -------------------------------------------------
# Container Core Functions Script
# -------------------------------------------------
# This script defines core functions for container initialization,
# service management, and utility operations.

# -------------------------------
# Import Defaults
# -------------------------------
# Load default container configuration variables.
source /src/config/defaults/00-container

# -------------------------------
# Color Configuration
# -------------------------------
# Define background colors for terminal outputs.
bdg="\e[42m"       # Dark Green
bdb="\e[44m"       # Dark Blue
bdm="\e[45m"       # Dark Magenta
bdgy="\e[100m"     # Dark Gray
blr="\e[101m"      # Light Red
boff="\e[49m"      # Reset Background Color

# -------------------------------
# Initialization Checks
# -------------------------------
# Check if the container initialization scripts have completed.
check_container_initialized() {
    print_debug "Checking if container initialization scripts have completed"

    # Disable output to avoid cluttering logs.
    output_off

    # Loop until the initialization flag file is present.
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Container initialization scripts not yet completed, retrying..."
        sleep 1
    done

    # Re-enable output after initialization is confirmed.
    output_on
}

# Check if a specific service within the container has been initialized.
check_service_initialized() {
    print_debug "Checking if service has been initialized"

    # Disable output to avoid cluttering logs.
    output_off

    # Determine the service suffix and bypass flag based on input arguments.
    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    # Determine the service name if bypass is disabled.
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    # Wait until the service initialization flag file is present.
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        print_debug "Waiting for service initialization: /tmp/.container/${service}${service_suffix}"
        sleep 1
    done

    # Clean up temporary variables.
    unset csi_bypass

    # Re-enable output after initialization is confirmed.
    output_on
}

# -------------------------------------------------
# Repository Management
# -------------------------------------------------
# This function clones a Git repository to a specified location
# with optional branch/tag and directory support.
clone_git_repo() {
    # Disable debug mode temporarily to avoid unnecessary log clutter.
    set +x
    if [ "${DEBUG_MODE,,}" = "true" ]; then set -x; fi

    # Check if Git is installed.
    if ! command -v git > /dev/null; then
        echo "[clone_git_repo] Git is not installed."
        exit 1
    fi

    # Configure Git to use the default branch as "main".
    git config --global init.defaultBranch main

    # Validate and process input arguments.
    if [ -n "$1" ]; then
        local repo
        local repo_name
        local repo_commit
        local repo_text=""
        local append_git_prefix=""

        # Determine repository target directory.
        if [ -n "$3" ]; then
            repo="$3/"
            repo_text="to '${3}'"
        else
            repo="/usr/src/$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        # Generate a sanitized repository name.
        repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"

        # Export environment variables for the repository.
        export GIT_REPO_SRC="${repo}"
        export GIT_REPO_SRC_${repo_name^^}="${repo}"

        # Check if the target directory already exists.
        if [ -d "${repo}" ]; then
            echo "[clone_git_repo] Directory ${repo} already exists. Cannot clone."
            exit 1
        fi

        # Append ".git" suffix if not present.
        if [[ $1 != *".git" ]]; then
            append_git_prefix=".git"
        fi

        # Clone the repository.
        mkdir -p "${repo}"
        cd "${repo}" || exit 1
        git init .
        git remote add origin "${1}${append_git_prefix}"

        if [ -n "$2" ]; then
            repo_commit="$2"
        fi

        echo "[clone_git_repo] Cloning Git Repo '${1}' '${repo_commit}' ${repo_text}"
        git fetch --depth=1 origin "${repo_commit}" +refs/tags/*:refs/tags/*
        git fetch --depth=1 origin "${repo_commit}"
        git -c advice.detachedHead=false checkout FETCH_HEAD
        git submodule update --init
    else
        echo "[clone_git_repo] No arguments provided to the function."
        exit 1
    fi

    # Re-enable debug mode if it was initially enabled.
    set -x
}

# Install a configuration template to a destination path.
install_template() {
    # Validate required arguments
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        print_error "[install_template] Missing required arguments."
        exit 1
    fi

    # Assign arguments to local variables
    local user="$1"
    local source_file="$2"
    local destination_file="$3"
    local template_mode="${4:-0644}"

    # Check if the source file exists
    if [ ! -f "$source_file" ]; then
        print_error "[install_template] Source file not found: $source_file"
        exit 1
    fi

    # Create destination directory if it does not exist
    if [ ! -d "$(dirname "$destination_file")" ]; then
        mkdir -p "$(dirname "$destination_file")"
    fi

    # Copy the template to the destination
    cp "$source_file" "$destination_file"

    # Set file permissions
    chmod "$template_mode" "$destination_file"

    # Set file ownership
    chown "$user" "$destination_file"

    # Print success message
    print_info "[install_template] Template installed successfully to $destination_file"
}

# Updates template files by replacing placeholders with environment variable values.
update_template() {
    # Validate required arguments
    if [ -z "$1" ]; then
        print_error "[update_template] No template files provided."
        return 1
    fi

    # Parse arguments
    local template_files="$1"
    shift
    local template_variables=("$@")

    # Process each template file
    for template_file in $(echo "${template_files}" | tr " " "\n"); do
        # Check if the template file exists
        if [ ! -f "${template_file}" ]; then
            print_error "[update_template] Template file not found: ${template_file}"
            return 1
        fi

        # Gather template metadata
        local template_user
        template_user=$(stat -c %U "${template_file}")
        local template_tmp_file
        template_tmp_file=$(mktemp)

        # Copy the template to a temporary file
        cp -a "${template_file}" "${template_tmp_file}"

        # Replace placeholders in the temporary template file
        for template_variable in "${template_variables[@]}"; do
            # Maintain compatibility: {{VAR}} -> ${VAR}
            sed -ri "s/[{]{2}${template_variable}[}]{2}/\${${template_variable}}/g" "${template_tmp_file}"
            print_debug "[update_template] Updating '${template_file}' with variable '${template_variable}'"
        done

        # Replace placeholders with actual variable values
        (
            export "${template_variables[@]}"
            local IFS=":"
            sudo -HEu "${template_user}" envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )

        # Clean up temporary file
        rm -f "${template_tmp_file}"

        print_info "[update_template] Template updated successfully: ${template_file}"
    done
}

# -------------------------------
# Logging and Debugging
# -------------------------------
# Generates a formatted log prefix with date and time.
log_prefix() {
    # Disable output to prevent unwanted logs during prefix generation
    output_off

    # Check if log prefix is enabled
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        local current_date
        local current_time
        local prefix_separator="${CONTAINER_LOG_PREFIX_SEPERATOR}"

        # Generate formatted date and time strings
        current_date=$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")
        current_time=$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}")

        # Output the log prefix
        echo "${current_date}${prefix_separator}${current_time} "
    fi

    # Re-enable output after prefix generation
    output_on
}

# Print debug messages to the console and/or log file if enabled.
print_debug() {
    # Disable output temporarily to prevent unwanted clutter
    output_off

    # Check if debug logging is enabled for console output
    if [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
        local log_message="$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        local log_message_colorized="$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if debug logging is enabled for log files
    if [ "${CONTAINER_LOG_FILE_LEVEL,,}" = "debug" ]; then
        echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs error messages to the console and/or log file based on configuration settings.
print_error() {
    # Disable output temporarily to avoid unwanted log clutter
    output_off

        local log_message
    local log_message_colorized

    # Prepare the log messages for plain and colored output
    log_message="$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if console error logging is enabled based on log level
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if file error logging is enabled based on file log level
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs informational messages to the console and/or log file.
print_info() {
    # Temporarily disable output to avoid unwanted log clutter
    output_off

    # Prepare log messages for plain and colorized output
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if debug mode is enabled for console output
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
        fi
    fi

    # Always log the message into the log file
    echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"

    # Re-enable output after processing
    output_on
}

# Logs notice messages to the console and/or log file based on configuration settings.
print_notice() {
    # Temporarily disable output to prevent unnecessary clutter in logs
    output_off

    local log_message
    local log_message_colorized

    # Prepare log messages for plain and colorized outputs
    log_message="$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs service startup details, manages process counters, and handles runaway protection.
print_start() {
    # Disable output temporarily to prevent log clutter
    output_off

    local proc_start_count=1
    local proc_start_wrapper=""
    local proc_help_arg=""
    local SHOW_OUTPUT="FALSE"

    # Process Counter Handling
    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ]; then
        if [ -f "/tmp/.container/$(basename "$PWD")" ]; then
            proc_start_count=$(wc -l < "/tmp/.container/$(basename "$PWD")")
            proc_start_wrapper="[${proc_start_count}] "
        fi

        proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$PWD") ${proc_start_count} $(cat /etc/hostname)"

        # Run helper script if available
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" "${proc_help_arg}"
            elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" "${proc_help_arg}"
            fi
        fi

        # Runaway Protection
        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ]; then
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ] && [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                SHOW_OUTPUT="TRUE"
            fi

            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                print_error "POTENTIAL RUNAWAY DETECTED: Disabling $(basename "$PWD") service after ${CONTAINER_PROCESS_RUNAWAY_LIMIT} restarts."
                s6-svc -d "/var/run/s6/legacy-services/$(basename "$PWD")"
                sleep 3
                exit 1
            fi

            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ]; then
                sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"
            fi
        fi
    fi

    # Logging Startup Information
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    log_message_colorized="$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"

    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs warning messages to the console and/or log file based on configuration settings.
print_warn() {
    # Temporarily disable output to prevent unwanted clutter
    output_off

    local log_message
    local log_message_colorized

    # Prepare plain and colorized log messages
    log_message="$(log_prefix)[WARN] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level allows warning messages
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log file level allows warning messages
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# -------------------------------
# Utility Functions
# -------------------------------
# General utility functions for container management.
# Check if a specific database type is ready for connection
db_ready() {
    # Disable output to avoid unnecessary log clutter
    output_off

    local db_type="${1,,}"
    local db_host db_port db_user db_pass db_name counter=0
    declare -A db_default_ports=(
        ["couchdb"]=5984
        ["influxdb"]=8088
        ["mongodb"]=27017
        ["mysql"]=3306
        ["postgresql"]=5432
        ["rabbitmq"]=5672
        ["redis"]=6379
        ["rethinkdb"]=28015
    )

    print_debug "Checking if Database Type '${db_type}' is ready"

    # Configure host and port based on database type
    case "${db_type}" in
        "couch" | "couchdb")
            db_port="${COUCHDB_PORT:-${DB_PORT:-${db_default_ports[couchdb]}}}"
            db_host="${COUCHDB_HOST:-${DB_HOST}}"
            ;;
        "influx" | "influxdb")
            db_port="${INFLUXDB_PORT:-${DB_PORT:-${db_default_ports[influxdb]}}}"
            db_host="${INFLUXDB_HOST:-${DB_HOST}}"
            ;;
        "mongo" | "mongodb")
            db_port="${MONGO_PORT:-${DB_PORT:-${db_default_ports[mongodb]}}}"
            db_host="${MONGO_HOST:-${DB_HOST}}"
            ;;
        "mysql" | "mariadb")
            if command -v "mariadb-admin" &>/dev/null; then
                mysqladmin_bin="$(which mariadb-admin)"
            elif command -v "mysqladmin" &>/dev/null; then
                mysqladmin_bin="$(which mysqladmin)"
            else
                print_error "No MySQL or MariaDB client detected - Cannot check for Database"
                exit 1
            fi

            # Disable SSL if necessary
            if [ ! -f /etc/my.cnf.d/disable-ssl.cnf ]; then
                mkdir -p /etc/my.cnf.d
                cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
                print_info "SSL has been disabled for MySQL/MariaDB client."
            fi

            db_port="${MYSQL_PORT:-${DB_PORT:-${db_default_ports[mysql]}}}"
            db_host="${MYSQL_HOST:-${DB_HOST}}"
            db_user="${MYSQL_USER:-${DB_USER}}"
            db_pass="${MYSQL_PASS:-${DB_PASS}}"
            ;;
        "pgsql" | "psql" | "postgres" | "postgresql")
            if ! command -v "pg_isready" &>/dev/null; then
                print_error "No PostgreSQL client detected - Cannot check for Database"
                exit 1
            fi

            db_port="${POSTGRES_PORT:-${DB_PORT:-${db_default_ports[postgresql]}}}"
            db_host="${POSTGRES_HOST:-${DB_HOST}}"
            db_user="${POSTGRES_USER:-${DB_USER}}"
            db_pass="${PGPASSWORD:-${DB_PASS}}"
            db_name="${POSTGRES_NAME:-${DB_NAME}}"
            export PGPASSWORD="${db_pass}"
            ;;
        "rabbit" | "rabbitmq")
            db_port="${RABBIT_PORT:-${DB_PORT:-${db_default_ports[rabbitmq]}}}"
            db_host="${RABBIT_HOST:-${DB_HOST}}"
            ;;
        "redis")
            db_port="${REDIS_PORT:-${DB_PORT:-${db_default_ports[redis]}}}"
            db_host="${REDIS_HOST:-${DB_HOST}}"
            ;;
        "rethink" | "rethinkdb")
            db_port="${RETHINK_PORT:-${DB_PORT:-${db_default_ports[rethinkdb]}}}"
            db_host="${RETHINK_HOST:-${DB_HOST}}"
            ;;
        *)
            print_error "Unsupported database type: ${db_type}"
            output_on
            return 1
            ;;
    esac

    # Generic database connection check
    counter=0
    while ! (nc -z "${db_host}" "${db_port}"); do
        sleep 5
        ((counter += 5))
        print_warn "Database '${db_type}' at '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
    done

    # Specific checks for MySQL/MariaDB and PostgreSQL
    case "${db_type}" in
        "mysql" | "mariadb")
            while ! ("${mysqladmin_bin}" -u"${db_user}" -P"${db_port}" -h"${db_host}" -p"${db_pass}" status &>/dev/null); do
                sleep 5
                ((counter += 5))
                print_warn "MySQL/MariaDB '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
            done
            ;;
        "pgsql" | "psql" | "postgres" | "postgresql")
            until pg_isready --dbname="${db_name}" --host="${db_host}" --port="${db_port}" --username="${db_user}" -q; do
                sleep 5
                ((counter += 5))
                print_warn "PostgreSQL '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
            done
            ;;
    esac

    print_info "Database '${db_type}' at '${db_host}:${db_port}' is ready."
    output_on
}

# Checks if a given directory is empty and returns 0 if empty, 1 if not.
dir_empty() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[dir_empty] Directory path is required."
        return 1
    fi

    local dir_path="$1"

    # Check if the provided path is a valid directory
    if [ ! -d "$dir_path" ]; then
        print_error "[dir_empty] '$dir_path' is not a valid directory."
        return 1
    fi

    # Check if the directory is empty
    if [ -z "$(find "$dir_path" -mindepth 1 -print -quit 2>/dev/null)" ]; then
        return 0
    else
        return 1
    fi
}

# Checks if a directory is not empty, validates input, and ensures it's valid.
dir_notempty() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[dir_notempty] Directory path is required."
        return 1
    fi

    local dir_path="$1"

    # Check if the provided path is a valid directory
    if [ ! -d "$dir_path" ]; then
        print_error "[dir_notempty] '$dir_path' is not a valid directory."
        return 1
    fi

    # Check if the directory is not empty
    if [ -n "$(find "$dir_path" -mindepth 1 -print -quit 2>/dev/null)" ]; then
        return 0
    else
        return 1
    fi
}

# Reads environment variable values from a file if _FILE suffix is provided.
file_env() {
    # Validate if Docker Secrets feature is enabled
    if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" != "true" ]; then
        return 0
    fi

    # Define local variables
    local var="$1"
    local file_var="${var}_FILE"
    local default_value="${2:-}"
    local value="$default_value"

    # Check if the file variable is set and read its content
    if [ -n "${!file_var:-}" ] && [ -f "${!file_var}" ]; then
        value="$(cat "${!file_var}")"
    elif [ -n "${!var:-}" ]; then
        value="${!var}"
    fi

    # Validate if value is still empty
    if [ -z "${value}" ]; then
        print_error "error: neither $var nor $file_var are set but are required"
        exit 1
    fi

    # Export the resolved value to the environment
    export "$var"="$value"
    unset "$file_var"
}

# Load default configuration files based on the specified scope.
get_defaults() {
    # Validate input argument
    local scope="$1"

    # Load all default configuration files
    if [ -n "$scope" ]; then
        case "${scope,,}" in
            "all")
                for config_file in /src/config/defaults/*; do
                    print_debug "Container: Loading defaults for '${config_file}' (ALL)"
                    case "$(basename "${config_file}")" in
                        0*-* | 99-*)
                            output_off
                            source "${config_file}"
                            output_on
                            ;;
                        *)
                            source "${config_file}"
                            ;;
                    esac
                done
                ;;

            "app" | "single")
                local config_target=""
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                        config_target="/src/config/defaults/$(basename "$0")"
                        ;;
                    *)
                        config_target="/src/config/defaults/$(basename "$PWD")"
                        ;;
                esac

                if [ -f "$config_target" ]; then
                    print_debug "Container: Loading defaults for '$(basename "$config_target")'"
                    case "$(basename "$config_target")" in
                        0*-* | 99-*)
                            output_off
                            source "$config_target"
                            output_on
                            ;;
                        *)
                            source "$config_target"
                            ;;
                    esac
                else
                    print_debug "Container: No defaults available for '$(basename "$config_target")'"
                fi
                ;;

            *)
                local defaults_list
                defaults_list=$(echo "$scope" | tr "," "\n")
                for config_name in $defaults_list; do
                    local config_path="/src/config/defaults/${config_name}"
                    if [ -f "$config_path" ]; then
                        print_debug "Container: Loading defaults for '${config_name}'"
                        case "${config_name}" in
                            0*-* | 99-*)
                                output_off
                                source "$config_path"
                                output_on
                                ;;
                            *)
                                source "$config_path"
                                ;;
                        esac
                    else
                        print_debug "Container: No defaults available for '${config_name}'"
                    fi
                done
                ;;
        esac
    else
        # Load defaults without specific scope
        for config_file in /src/config/defaults/*; do
            print_debug "Container: Loading defaults for '${config_file}'"
            case "$(basename "${config_file}")" in
                0*-* | 99-*)
                    output_off
                    source /src/config/defaults/00-container
                    source "${config_file}"
                    output_on
                    ;;
                *)
                    source /src/config/defaults/00-container
                    source "${config_file}"
                    ;;
            esac
        done
    fi
}

# Load function files based on a specified scope or load all if no scope is provided.
get_functions() {
    # Validate input argument
    local scope="$1"

    # Load all function files except '00-container'
    if [ -n "$scope" ]; then
        case "${scope,,}" in
            "all")
                for func_file in /src/core/functions/*; do
                    if [ "$func_file" != "/src/core/functions/00-container" ]; then
                        print_debug "Container: Loading functions from '${func_file}' (ALL)"
                        source "${func_file}"
                    fi
                done
                ;;

            "app" | "single")
                local func_target=""
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                        func_target="/src/core/functions/$(basename "$0")"
                        ;;
                    *)
                        func_target="/src/core/functions/$(basename "$PWD")"
                        ;;
                esac

                if [ -f "$func_target" ]; then
                    print_debug "Container: Loading functions from '$(basename "$func_target")'"
                    source "$func_target"
                else
                    print_debug "Container: No functions available for '$(basename "$func_target")'"
                fi
                ;;

            *)
                local function_list
                function_list=$(echo "$scope" | tr "," "\n")
                for func_name in $function_list; do
                    local func_path="/src/core/functions/${func_name}"
                    if [ -f "$func_path" ]; then
                        print_debug "Container: Loading functions from '${func_name}'"
                        source "$func_path"
                    else
                        print_debug "Container: No functions available for '${func_name}'"
                    fi
                done
                ;;
        esac
    else
        # Load all function files by default
        for func_file in /src/core/functions/*; do
            if [ "$func_file" != "/src/core/functions/00-container" ]; then
                print_debug "Container: Loading functions from '${func_file}'"
                source "${func_file}"
            fi
        done
    fi
}

# Grants 'doas' privileges to a specified user for specific commands.
grant_doas() {
    # Temporarily disable output to prevent unwanted logs
    output_off

    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[grant_doas] User is required."
        output_on
        return 1
    fi

    local user="$1"
    local doas_command=""

    print_debug "Adding 'doas' privileges to user: '$user'"

    # Check if a specific command is provided
    if [ -n "$2" ]; then
        doas_command="cmd $2"
        print_debug "Adding 'doas' privileges for command: '$2'"
    fi

    # Append configuration to doas.conf
    echo "permit nopass $user ${doas_command} as root" >> /etc/doas.conf

    # Ensure correct file ownership and permissions
    chown root:root /etc/doas.conf
    chmod 0400 /etc/doas.conf

    print_info "'doas' privileges successfully added for user: '$user'"

    # Re-enable output
    output_on
}

# Grants 'sudo' privileges to a specified user with optional command restrictions.
grant_sudo() {
    # Temporarily disable output to avoid unnecessary logs
    output_off

    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[grant_sudo] User is required."
        output_on
        return 1
    fi

    local user="$1"
    local sudo_command="ALL"

    # If a specific command is provided, set sudo_command
    if [ -n "$2" ]; then
        sudo_command="$2"
        print_debug "Adding 'sudo' privileges to user '$user' for command '$sudo_command'"
    else
        print_debug "Adding 'sudo' privileges to user '$user' for all commands"
    fi

    # Append sudo configuration to /etc/sudoers
    echo "%$user ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers

    # Validate sudoers file syntax
    if ! visudo -c >/dev/null 2>&1; then
        print_error "[grant_sudo] Invalid syntax in /etc/sudoers file. Reverting changes."
        sed -i "\|%$user ALL=(ALL) NOPASSWD:${sudo_command}|d" /etc/sudoers
        output_on
        return 1
    fi

    print_info "'sudo' privileges successfully added for user: '$user'"

    # Re-enable output
    output_on
}

# Sets the system timezone if valid, ensuring proper validation and logging.
set_timezone() {
    # Validate if TIMEZONE variable is set
    if [ -z "${TIMEZONE}" ]; then
        print_error "[set_timezone] TIMEZONE variable is not set."
        return 1
    fi

    local current_timezone
    current_timezone="$(cat /etc/timezone 2>/dev/null || echo "UTC")"

    # Check if the specified timezone exists
    if [ -f "/usr/share/zoneinfo/${TIMEZONE}" ]; then
        if [ "${TIMEZONE}" != "${current_timezone}" ]; then
            print_notice "[set_timezone] Changing timezone from '${current_timezone}' to '${TIMEZONE}'"
            cp -f "/usr/share/zoneinfo/${TIMEZONE}" /etc/localtime
            echo "${TIMEZONE}" > /etc/timezone
            print_info "[set_timezone] Timezone successfully updated to '${TIMEZONE}'"
        else
            print_info "[set_timezone] Timezone is already set to '${TIMEZONE}'"
        fi
    else
        print_warn "[set_timezone] Specified timezone '${TIMEZONE}' does not exist. Retaining current timezone '${current_timezone}'"
    fi
}

# Converts environment variables ending with '_FILE' into their content values if they point to valid files.
transform_file_var() {
    # Extract and iterate through all provided variables
    local variables
    variables=$(echo "$@" | tr " " "\n")

    for variable in $variables; do
        local file_variable="${variable}_FILE"

        # Check if a corresponding *_FILE variable exists
        if [ -v "${file_variable}" ]; then
            # Validate if the file exists
            if [ ! -f "${!file_variable}" ]; then
                print_error "[transform_file_var] ${file_variable} is set, but the file does not exist."
                return 1
            fi

            # Replace variable value with file content
            export "${variable}"="$(cat "${!file_variable}")"
            print_debug "[transform_file_var] Transformed '${variable}' from file '${!file_variable}'"
        fi
    done

    # Clean up temporary variables
    unset file_variable
    unset variables
}

# -------------------------------
# Service Management
# -------------------------------
# FUNCTIONS TO MANAGE SERVICES IN THE CONTAINER.
# Loads default configurations and functions for a service based on the specified mode and context.
prepare_service() {
    # Validate if a parameter is provided
    if [ -n "$1" ]; then
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                # Load defaults and functions in the init directory context
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
                ;;
            *)
                # Handle different modes for loading defaults and functions
                case "${1,,}" in
                    "BOTH" | "both" | "ALL" | "all")
                        get_defaults "$2"
                        get_functions "$2"
                        ;;
                    "DEFAULTS" | "defaults")
                        get_defaults "$2"
                        ;;
                    "FUNCTIONS" | "functions")
                        get_functions "$2"
                        ;;
                    *)
                        print_error "[prepare_service] Invalid mode: '$1'"
                        return 1
                        ;;
                esac
                ;;
        esac
    else
        # Default behavior if no parameter is provided
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
                ;;
            *)
                get_defaults
                ;;
        esac
    fi
}

# Enables a specified service by creating a symbolic link in /etc/services.d.
service_start() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[service_start] Service name is required."
        return 1
    fi

    local service_name="$1"
    local available_service_path="/etc/services.available/${service_name}"
    local enabled_service_path="/etc/services.d/${service_name}"

    # Check if the service exists in available services
    if [ ! -e "$available_service_path" ]; then
        print_error "[service_start] Service '${service_name}' does not exist in /etc/services.available."
        return 1
    fi

    # Create symbolic link to enable the service
    ln -sf "$available_service_path" "$enabled_service_path"

    # Verify if the symbolic link was successfully created
    if [ -L "$enabled_service_path" ]; then
        print_info "[service_start] Service '${service_name}' successfully started."
    else
        print_error "[service_start] Failed to start service '${service_name}'."
        return 1
    fi
}

# Prevents a specified service from starting by marking it with a 'DONOTSTART' flag.
service_stop() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[service_stop] Service name is required."
        return 1
    fi

    local service_name="$1"
    local service_flag_file="/tmp/.container/${service_name}-init"

    # Add 'DONOTSTART' marker to prevent the service from starting
    echo "DONOTSTART added by $(basename "$0")" >> "$service_flag_file"

    # Verify if the flag was successfully added
    if grep -q "DONOTSTART" "$service_flag_file"; then
        print_info "[service_stop] Service '${service_name}' has been marked with 'DONOTSTART'."
    else
        print_error "[service_stop] Failed to mark service '${service_name}' with 'DONOTSTART'."
        return 1
    fi
}

# -------------------------------
# Service Management
# -------------------------------
# FUNCTIONS TO MANAGE SERVICES IN THE CONTAINER.
# Waits until a specified directory exists before proceeding.
wait_for_directory() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[wait_for_directory] Directory path is required."
        return 1
    fi

    local dir_path="$1"
    local retry_interval=1  # Time interval between retries in seconds

    print_debug "[wait_for_directory] Waiting for directory: '${dir_path}'"

    # Loop until the directory exists
    while [ ! -d "${dir_path}" ]; do
        sleep "${retry_interval}"
        print_debug "[wait_for_directory] Directory '${dir_path}' not found. Retrying in ${retry_interval}s..."
    done

    print_info "[wait_for_directory] Directory '${dir_path}' now exists."
}

# Waits until a specified file exists before continuing execution.
wait_for_file() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[wait_for_file] File path is required."
        return 1
    fi

    local file_path="$1"
    local retry_interval=1  # Time interval between retries in seconds

    print_debug "[wait_for_file] Waiting for file: '${file_path}'"

    # Wait until the file exists
    while [ ! -f "${file_path}" ]; do
        sleep "${retry_interval}"
        print_debug "[wait_for_file] File '${file_path}' not found. Retrying in ${retry_interval}s..."
    done

    print_info "[wait_for_file] File '${file_path}' now exists."
}

# Waits until a host and port are available for connection.
wait_for_port() {
    # Validate input arguments
    if [ -z "$1" ] || [ -z "$2" ]; then
        print_error "[wait_for_port] Host and port are required."
        return 1
    fi

    local host="$1"
    local port="$2"
    local retry_interval=5   # Time interval between retries in seconds
    local timeout=300        # Maximum wait time in seconds
    local counter=0

    print_debug "[wait_for_port] Waiting for '${host}:${port}' to become available."

    # Loop until the port is open or timeout is reached
    while ! (nc -z "${host}" "${port}"); do
        sleep "${retry_interval}"
        ((counter += retry_interval))

        print_warn "[wait_for_port] Host '${host}' is not listening on port '${port}', retrying... (${counter}s elapsed)"

        if [ "${counter}" -ge "${timeout}" ]; then
            print_error "[wait_for_port] Timeout reached. Host '${host}' did not open port '${port}'."
            return 1
        fi
    done

    print_info "[wait_for_port] Host '${host}' is now listening on port '${port}'."
}
