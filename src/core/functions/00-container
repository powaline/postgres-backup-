#!/command/with-contenv bash

# -------------------------------------------------
# CONTAINER CORE FUNCTIONS SCRIPT
# -------------------------------------------------
# This script defines core functions for container initialization,
# service management, and utility operations.

# -------------------------------
# IMPORT DEFAULTS
# -------------------------------
# Load default container configuration variables.
source /src/config/defaults/00-container

# -------------------------------
# COLOR CONFIGURATION
# -------------------------------
# Define background colors for terminal outputs.
bdg="\e[42m"       # Dark Green
bdb="\e[44m"       # Dark Blue
bdm="\e[45m"       # Dark Magenta
bdgy="\e[100m"     # Dark Gray
blr="\e[101m"      # Light Red
boff="\e[49m"      # Reset Background Color

# -------------------------------
# INITIALIZATION CHECKS
# -------------------------------
# Functions to check initialization status.
# Verifies if container initialization scripts have completed by checking for a flag file.
check_container_initialized() {
    print_debug "Checking if container initialization scripts have completed"

    # Disable output to avoid cluttering logs.
    output_off

    # Loop until the initialization flag file is present.
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Container initialization scripts not yet completed, retrying..."
        sleep 1
    done

    # Re-enable output after initialization is confirmed.
    output_on
}

# Check if a specific service within the container has been initialized.
check_service_initialized() {
    print_debug "Checking if service has been initialized"

    # Disable output to avoid cluttering logs.
    output_off

    # Determine the service suffix and bypass flag based on input arguments.
    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    # Determine the service name if bypass is disabled.
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    # Wait until the service initialization flag file is present.
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        print_debug "Waiting for service initialization: /tmp/.container/${service}${service_suffix}"
        sleep 1
    done

    # Clean up temporary variables.
    unset csi_bypass

    # Re-enable output after initialization is confirmed.
    output_on
}

# Ensures proper container initialization state by logging status.
liftoff() {
    # Temporarily disable output to avoid clutter.
    output_off

    # Ensure the temporary container state directory exists.
    local state_dir="/tmp/.container"
    mkdir -p "${state_dir}"

    # Determine if DONOTSTART prefix should be applied.
    local liftoff_prefix=""
    if [ "${DONOTSTART}" = "TRUE" ]; then
        liftoff_prefix="DONOTSTART "
    fi

    # Handle initialization based on the script's directory.
    local init_file=""
    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
            init_file="${state_dir}/$(basename "$0")-init"
            echo "${liftoff_prefix}$(basename "$0")-init initialized on $(log_prefix)" >> "${init_file}"
            ;;
        *)
            init_file="${state_dir}/$(basename "$PWD")"
            if [ ! -f "${init_file}" ]; then
                echo "$(basename "$PWD") initialized on $(log_prefix)" >> "${init_file}"
            else
                echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> "${init_file}"
            fi
            ;;
    esac

    # Re-enable output.
    output_on
}

# -------------------------------
# REPOSITORY MANAGEMENT
# -------------------------------
# Functions to manage repositories and templates.
# Clones a Git repository into a target directory with optional commit and branch support.
clone_git_repo() {
    # Disable debug mode temporarily to avoid unnecessary log clutter.
    set +x
    if [ "${DEBUG_MODE,,}" = "true" ]; then set -x; fi

    # Check if Git is installed.
    if ! command -v git > /dev/null; then
        echo "[clone_git_repo] Git is not installed."
        exit 1
    fi

    # Configure Git to use the default branch as "main".
    git config --global init.defaultBranch main

    # Validate and process input arguments.
    if [ -n "$1" ]; then
        local repo
        local repo_name
        local repo_commit
        local repo_text=""
        local append_git_prefix=""

        # Determine repository target directory.
        if [ -n "$3" ]; then
            repo="$3/"
            repo_text="to '${3}'"
        else
            repo="/usr/src/$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        # Generate a sanitized repository name.
        repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"

        # Export environment variables for the repository.
        export GIT_REPO_SRC="${repo}"
        export GIT_REPO_SRC_${repo_name^^}="${repo}"

        # Check if the target directory already exists.
        if [ -d "${repo}" ]; then
            echo "[clone_git_repo] Directory ${repo} already exists. Cannot clone."
            exit 1
        fi

        # Append ".git" suffix if not present.
        if [[ $1 != *".git" ]]; then
            append_git_prefix=".git"
        fi

        # Clone the repository.
        mkdir -p "${repo}"
        cd "${repo}" || exit 1
        git init .
        git remote add origin "${1}${append_git_prefix}"

        if [ -n "$2" ]; then
            repo_commit="$2"
        fi

        echo "[clone_git_repo] Cloning Git Repo '${1}' '${repo_commit}' ${repo_text}"
        git fetch --depth=1 origin "${repo_commit}" +refs/tags/*:refs/tags/*
        git fetch --depth=1 origin "${repo_commit}"
        git -c advice.detachedHead=false checkout FETCH_HEAD
        git submodule update --init
    else
        echo "[clone_git_repo] No arguments provided to the function."
        exit 1
    fi

    # Re-enable debug mode if it was initially enabled.
    set -x
}

# Install a configuration template to a destination path.
install_template() {
    # Validate required arguments
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        print_error "[install_template] Missing required arguments."
        exit 1
    fi

    # Assign arguments to local variables
    local user="$1"
    local source_file="$2"
    local destination_file="$3"
    local template_mode="${4:-0644}"

    # Check if the source file exists
    if [ ! -f "$source_file" ]; then
        print_error "[install_template] Source file not found: $source_file"
        exit 1
    fi

    # Create destination directory if it does not exist
    if [ ! -d "$(dirname "$destination_file")" ]; then
        mkdir -p "$(dirname "$destination_file")"
    fi

    # Copy the template to the destination
    cp "$source_file" "$destination_file"

    # Set file permissions
    chmod "$template_mode" "$destination_file"

    # Set file ownership
    chown "$user" "$destination_file"

    # Print success message
    print_info "[install_template] Template installed successfully to $destination_file"
}

# Updates template files by replacing placeholders with environment variable values.
update_template() {
    # Validate required arguments
    if [ -z "$1" ]; then
        print_error "[update_template] No template files provided."
        return 1
    fi

    # Parse arguments
    local template_files="$1"
    shift
    local template_variables=("$@")

    # Process each template file
    for template_file in $(echo "${template_files}" | tr " " "\n"); do
        # Check if the template file exists
        if [ ! -f "${template_file}" ]; then
            print_error "[update_template] Template file not found: ${template_file}"
            return 1
        fi

        # Gather template metadata
        local template_user
        template_user=$(stat -c %U "${template_file}")
        local template_tmp_file
        template_tmp_file=$(mktemp)

        # Copy the template to a temporary file
        cp -a "${template_file}" "${template_tmp_file}"

        # Replace placeholders in the temporary template file
        for template_variable in "${template_variables[@]}"; do
            # Maintain compatibility: {{VAR}} -> ${VAR}
            sed -ri "s/[{]{2}${template_variable}[}]{2}/\${${template_variable}}/g" "${template_tmp_file}"
            print_debug "[update_template] Updating '${template_file}' with variable '${template_variable}'"
        done

        # Replace placeholders with actual variable values
        (
            export "${template_variables[@]}"
            local IFS=":"
            sudo -HEu "${template_user}" envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )

        # Clean up temporary file
        rm -f "${template_tmp_file}"

        print_info "[update_template] Template updated successfully: ${template_file}"
    done
}

# -------------------------------
# SERVICE MANAGEMENT
# -------------------------------
# Functions to manage services in the container.
# Loads default configurations and functions for a service based on the specified mode and context.
prepare_service() {
    # Validate if a parameter is provided
    if [ -n "$1" ]; then
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                # Load defaults and functions in the init directory context
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
                ;;
            *)
                # Handle different modes for loading defaults and functions
                case "${1,,}" in
                    "BOTH" | "both" | "ALL" | "all")
                        get_defaults "$2"
                        get_functions "$2"
                        ;;
                    "DEFAULTS" | "defaults")
                        get_defaults "$2"
                        ;;
                    "FUNCTIONS" | "functions")
                        get_functions "$2"
                        ;;
                    *)
                        print_error "[prepare_service] Invalid mode: '$1'"
                        return 1
                        ;;
                esac
                ;;
        esac
    else
        # Default behavior if no parameter is provided
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
                ;;
            *)
                get_defaults
                ;;
        esac
    fi
}

# Enables a specified service by creating a symbolic link in /etc/services.d.
service_start() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[service_start] Service name is required."
        return 1
    fi

    local service_name="$1"
    local available_service_path="/etc/services.available/${service_name}"
    local enabled_service_path="/etc/services.d/${service_name}"

    # Check if the service exists in available services
    if [ ! -e "$available_service_path" ]; then
        print_error "[service_start] Service '${service_name}' does not exist in /etc/services.available."
        return 1
    fi

    # Create symbolic link to enable the service
    ln -sf "$available_service_path" "$enabled_service_path"

    # Verify if the symbolic link was successfully created
    if [ -L "$enabled_service_path" ]; then
        print_info "[service_start] Service '${service_name}' successfully started."
    else
        print_error "[service_start] Failed to start service '${service_name}'."
        return 1
    fi
}

# Prevents a specified service from starting by marking it with a 'DONOTSTART' flag.
service_stop() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[service_stop] Service name is required."
        return 1
    fi

    local service_name="$1"
    local service_flag_file="/tmp/.container/${service_name}-init"

    # Add 'DONOTSTART' marker to prevent the service from starting
    echo "DONOTSTART added by $(basename "$0")" >> "$service_flag_file"

    # Verify if the flag was successfully added
    if grep -q "DONOTSTART" "$service_flag_file"; then
        print_info "[service_stop] Service '${service_name}' has been marked with 'DONOTSTART'."
    else
        print_error "[service_stop] Failed to mark service '${service_name}' with 'DONOTSTART'."
        return 1
    fi
}

# -------------------------------
# LOGGING AND DEBUGGING
# -------------------------------
# Functions for logging and debugging outputs.
# Generates a formatted log prefix with date and time.
log_prefix() {
    # Disable output to prevent unwanted logs during prefix generation
    output_off

    # Check if log prefix is enabled
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        local current_date
        local current_time
        local prefix_separator="${CONTAINER_LOG_PREFIX_SEPERATOR}"

        # Generate formatted date and time strings
        current_date=$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")
        current_time=$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}")

        # Output the log prefix
        echo "${current_date}${prefix_separator}${current_time} "
    fi

    # Re-enable output after prefix generation
    output_on
}

# Print debug messages to the console and/or log file if enabled.
print_debug() {
    # Disable output temporarily to prevent unwanted clutter
    output_off

    # Check if debug logging is enabled for console output
    if [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
        local log_message="$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        local log_message_colorized="$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if debug logging is enabled for log files
    if [ "${CONTAINER_LOG_FILE_LEVEL,,}" = "debug" ]; then
        echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs error messages to the console and/or log file based on configuration settings.
print_error() {
    # Disable output temporarily to avoid unwanted log clutter
    output_off

        local log_message
    local log_message_colorized

    # Prepare the log messages for plain and colored output
    log_message="$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if console error logging is enabled based on log level
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if file error logging is enabled based on file log level
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs informational messages to the console and/or log file.
print_info() {
    # Temporarily disable output to avoid unwanted log clutter
    output_off

    # Prepare log messages for plain and colorized output
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if debug mode is enabled for console output
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
        fi
    fi

    # Always log the message into the log file
    echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"

    # Re-enable output after processing
    output_on
}

# Logs notice messages to the console and/or log file based on configuration settings.
print_notice() {
    # Temporarily disable output to prevent unnecessary clutter in logs
    output_off

    local log_message
    local log_message_colorized

    # Prepare log messages for plain and colorized outputs
    log_message="$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs service startup details, manages process counters, and handles runaway protection.
print_start() {
    # Disable output temporarily to prevent log clutter
    output_off

    local proc_start_count=1
    local proc_start_wrapper=""
    local proc_help_arg=""
    local SHOW_OUTPUT="FALSE"

    # Process Counter Handling
    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ]; then
        if [ -f "/tmp/.container/$(basename "$PWD")" ]; then
            proc_start_count=$(wc -l < "/tmp/.container/$(basename "$PWD")")
            proc_start_wrapper="[${proc_start_count}] "
        fi

        proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$PWD") ${proc_start_count} $(cat /etc/hostname)"

        # Run helper script if available
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" "${proc_help_arg}"
            elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" "${proc_help_arg}"
            fi
        fi

        # Runaway Protection
        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ]; then
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ] && [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                SHOW_OUTPUT="TRUE"
            fi

            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                print_error "POTENTIAL RUNAWAY DETECTED: Disabling $(basename "$PWD") service after ${CONTAINER_PROCESS_RUNAWAY_LIMIT} restarts."
                s6-svc -d "/var/run/s6/legacy-services/$(basename "$PWD")"
                sleep 3
                exit 1
            fi

            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ]; then
                sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"
            fi
        fi
    fi

    # Logging Startup Information
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    log_message_colorized="$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"

    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs warning messages to the console and/or log file based on configuration settings.
print_warn() {
    # Temporarily disable output to prevent unwanted clutter
    output_off

    local log_message
    local log_message_colorized

    # Prepare plain and colorized log messages
    log_message="$(log_prefix)[WARN] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level allows warning messages
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log file level allows warning messages
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Temporarily disables debug output if DEBUG_MODE is enabled.
output_off() {
    # Check if DEBUG_MODE is set to true (case-insensitive).
    if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        set +x
    fi
}

# Enables debug output if DEBUG_MODE is enabled and conditions are met.
output_on() {
    # Check if DEBUG_MODE is enabled (case-insensitive).
    if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        local script_name
        local current_dir

        script_name="$(basename "$0")"
        current_dir="$PWD"

        # Check script name patterns and directory conditions.
        case "${script_name}" in
            0*-* | 99-*)
                # Skip enabling debug for initialization or special scripts.
                :
                ;;
            run)
                case "${current_dir}" in
                    */0*-* | */99-*)
                        # Skip enabling debug for specific directories.
                        :
                        ;;
                    *)
                        # Enable debug mode for other 'run' scripts.
                        set -x
                        ;;
                esac
                ;;
            *)
                # Enable debug mode for all other scripts.
                set -x
                ;;
        esac
    fi
}

# Executes a command silently unless DEBUG_MODE, SHOW_OUTPUT, or CONTAINER_LOG_LEVEL are enabled for logging.
silent() {
    # Check if debug or verbose output is enabled.
    if [[ "${DEBUG_MODE,,}" == "true" ]] || [[ "${SHOW_OUTPUT,,}" == "true" ]] || [[ "${CONTAINER_LOG_LEVEL,,}" == "debug" ]]; then
        # Run command with standard output.
        "$@"
    else
        # Run command silently, suppressing both stdout and stderr.
        "$@" > /dev/null 2>&1
    fi
}

# -------------------------------
# UTILITY FUNCTIONS
# -------------------------------
# General utility functions for container management.
# Check if a specific database type is ready for connection
db_ready() {
    # Disable output to avoid unnecessary log clutter
    output_off

    local db_type="${1,,}"
    local db_host db_port db_user db_pass db_name counter=0
    declare -A db_default_ports=(
        ["couchdb"]=5984
        ["influxdb"]=8088
        ["mongodb"]=27017
        ["mysql"]=3306
        ["postgresql"]=5432
        ["rabbitmq"]=5672
        ["redis"]=6379
        ["rethinkdb"]=28015
    )

    print_debug "Checking if Database Type '${db_type}' is ready"

    # Configure host and port based on database type
    case "${db_type}" in
        "couch" | "couchdb")
            db_port="${COUCHDB_PORT:-${DB_PORT:-${db_default_ports[couchdb]}}}"
            db_host="${COUCHDB_HOST:-${DB_HOST}}"
            ;;
        "influx" | "influxdb")
            db_port="${INFLUXDB_PORT:-${DB_PORT:-${db_default_ports[influxdb]}}}"
            db_host="${INFLUXDB_HOST:-${DB_HOST}}"
            ;;
        "mongo" | "mongodb")
            db_port="${MONGO_PORT:-${DB_PORT:-${db_default_ports[mongodb]}}}"
            db_host="${MONGO_HOST:-${DB_HOST}}"
            ;;
        "mysql" | "mariadb")
            if command -v "mariadb-admin" &>/dev/null; then
                mysqladmin_bin="$(which mariadb-admin)"
            elif command -v "mysqladmin" &>/dev/null; then
                mysqladmin_bin="$(which mysqladmin)"
            else
                print_error "No MySQL or MariaDB client detected - Cannot check for Database"
                exit 1
            fi

            # Disable SSL if necessary
            if [ ! -f /etc/my.cnf.d/disable-ssl.cnf ]; then
                mkdir -p /etc/my.cnf.d
                cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
                print_info "SSL has been disabled for MySQL/MariaDB client."
            fi

            db_port="${MYSQL_PORT:-${DB_PORT:-${db_default_ports[mysql]}}}"
            db_host="${MYSQL_HOST:-${DB_HOST}}"
            db_user="${MYSQL_USER:-${DB_USER}}"
            db_pass="${MYSQL_PASS:-${DB_PASS}}"
            ;;
        "pgsql" | "psql" | "postgres" | "postgresql")
            if ! command -v "pg_isready" &>/dev/null; then
                print_error "No PostgreSQL client detected - Cannot check for Database"
                exit 1
            fi

            db_port="${POSTGRES_PORT:-${DB_PORT:-${db_default_ports[postgresql]}}}"
            db_host="${POSTGRES_HOST:-${DB_HOST}}"
            db_user="${POSTGRES_USER:-${DB_USER}}"
            db_pass="${PGPASSWORD:-${DB_PASS}}"
            db_name="${POSTGRES_NAME:-${DB_NAME}}"
            export PGPASSWORD="${db_pass}"
            ;;
        "rabbit" | "rabbitmq")
            db_port="${RABBIT_PORT:-${DB_PORT:-${db_default_ports[rabbitmq]}}}"
            db_host="${RABBIT_HOST:-${DB_HOST}}"
            ;;
        "redis")
            db_port="${REDIS_PORT:-${DB_PORT:-${db_default_ports[redis]}}}"
            db_host="${REDIS_HOST:-${DB_HOST}}"
            ;;
        "rethink" | "rethinkdb")
            db_port="${RETHINK_PORT:-${DB_PORT:-${db_default_ports[rethinkdb]}}}"
            db_host="${RETHINK_HOST:-${DB_HOST}}"
            ;;
        *)
            print_error "Unsupported database type: ${db_type}"
            output_on
            return 1
            ;;
    esac

    # Generic database connection check
    counter=0
    while ! (nc -z "${db_host}" "${db_port}"); do
        sleep 5
        ((counter += 5))
        print_warn "Database '${db_type}' at '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
    done

    # Specific checks for MySQL/MariaDB and PostgreSQL
    case "${db_type}" in
        "mysql" | "mariadb")
            while ! ("${mysqladmin_bin}" -u"${db_user}" -P"${db_port}" -h"${db_host}" -p"${db_pass}" status &>/dev/null); do
                sleep 5
                ((counter += 5))
                print_warn "MySQL/MariaDB '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
            done
            ;;
        "pgsql" | "psql" | "postgres" | "postgresql")
            until pg_isready --dbname="${db_name}" --host="${db_host}" --port="${db_port}" --username="${db_user}" -q; do
                sleep 5
                ((counter += 5))
                print_warn "PostgreSQL '${db_host}:${db_port}' is not accessible, retrying... (${counter} seconds so far)"
            done
            ;;
    esac

    print_info "Database '${db_type}' at '${db_host}:${db_port}' is ready."
    output_on
}

# Checks if a given directory is empty and returns 0 if empty, 1 if not.
dir_empty() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[dir_empty] Directory path is required."
        return 1
    fi

    local dir_path="$1"

    # Check if the provided path is a valid directory
    if [ ! -d "$dir_path" ]; then
        print_error "[dir_empty] '$dir_path' is not a valid directory."
        return 1
    fi

    # Check if the directory is empty
    if [ -z "$(find "$dir_path" -mindepth 1 -print -quit 2>/dev/null)" ]; then
        return 0
    else
        return 1
    fi
}

# Checks if a directory is not empty, validates input, and ensures it's valid.
dir_notempty() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[dir_notempty] Directory path is required."
        return 1
    fi

    local dir_path="$1"

    # Check if the provided path is a valid directory
    if [ ! -d "$dir_path" ]; then
        print_error "[dir_notempty] '$dir_path' is not a valid directory."
        return 1
    fi

    # Check if the directory is not empty
    if [ -n "$(find "$dir_path" -mindepth 1 -print -quit 2>/dev/null)" ]; then
        return 0
    else
        return 1
    fi
}

# Reads environment variable values from a file if _FILE suffix is provided.
file_env() {
    # Validate if Docker Secrets feature is enabled
    if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" != "true" ]; then
        return 0
    fi

    # Define local variables
    local var="$1"
    local file_var="${var}_FILE"
    local default_value="${2:-}"
    local value="$default_value"

    # Check if the file variable is set and read its content
    if [ -n "${!file_var:-}" ] && [ -f "${!file_var}" ]; then
        value="$(cat "${!file_var}")"
    elif [ -n "${!var:-}" ]; then
        value="${!var}"
    fi

    # Validate if value is still empty
    if [ -z "${value}" ]; then
        print_error "error: neither $var nor $file_var are set but are required"
        exit 1
    fi

    # Export the resolved value to the environment
    export "$var"="$value"
    unset "$file_var"
}

# Load default configuration files based on the specified scope.
get_defaults() {
    # Validate input argument
    local scope="$1"

    # Load all default configuration files
    if [ -n "$scope" ]; then
        case "${scope,,}" in
            "all")
                for config_file in /src/config/defaults/*; do
                    print_debug "Container: Loading defaults for '${config_file}' (ALL)"
                    case "$(basename "${config_file}")" in
                        0*-* | 99-*)
                            output_off
                            source "${config_file}"
                            output_on
                            ;;
                        *)
                            source "${config_file}"
                            ;;
                    esac
                done
                ;;

            "app" | "single")
                local config_target=""
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                        config_target="/src/config/defaults/$(basename "$0")"
                        ;;
                    *)
                        config_target="/src/config/defaults/$(basename "$PWD")"
                        ;;
                esac

                if [ -f "$config_target" ]; then
                    print_debug "Container: Loading defaults for '$(basename "$config_target")'"
                    case "$(basename "$config_target")" in
                        0*-* | 99-*)
                            output_off
                            source "$config_target"
                            output_on
                            ;;
                        *)
                            source "$config_target"
                            ;;
                    esac
                else
                    print_debug "Container: No defaults available for '$(basename "$config_target")'"
                fi
                ;;

            *)
                local defaults_list
                defaults_list=$(echo "$scope" | tr "," "\n")
                for config_name in $defaults_list; do
                    local config_path="/src/config/defaults/${config_name}"
                    if [ -f "$config_path" ]; then
                        print_debug "Container: Loading defaults for '${config_name}'"
                        case "${config_name}" in
                            0*-* | 99-*)
                                output_off
                                source "$config_path"
                                output_on
                                ;;
                            *)
                                source "$config_path"
                                ;;
                        esac
                    else
                        print_debug "Container: No defaults available for '${config_name}'"
                    fi
                done
                ;;
        esac
    else
        # Load defaults without specific scope
        for config_file in /src/config/defaults/*; do
            print_debug "Container: Loading defaults for '${config_file}'"
            case "$(basename "${config_file}")" in
                0*-* | 99-*)
                    output_off
                    source /src/config/defaults/00-container
                    source "${config_file}"
                    output_on
                    ;;
                *)
                    source /src/config/defaults/00-container
                    source "${config_file}"
                    ;;
            esac
        done
    fi
}

# Load function files based on a specified scope or load all if no scope is provided.
get_functions() {
    # Validate input argument
    local scope="$1"

    # Load all function files except '00-container'
    if [ -n "$scope" ]; then
        case "${scope,,}" in
            "all")
                for func_file in /src/core/functions/*; do
                    if [ "$func_file" != "/src/core/functions/00-container" ]; then
                        print_debug "Container: Loading functions from '${func_file}' (ALL)"
                        source "${func_file}"
                    fi
                done
                ;;

            "app" | "single")
                local func_target=""
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                        func_target="/src/core/functions/$(basename "$0")"
                        ;;
                    *)
                        func_target="/src/core/functions/$(basename "$PWD")"
                        ;;
                esac

                if [ -f "$func_target" ]; then
                    print_debug "Container: Loading functions from '$(basename "$func_target")'"
                    source "$func_target"
                else
                    print_debug "Container: No functions available for '$(basename "$func_target")'"
                fi
                ;;

            *)
                local function_list
                function_list=$(echo "$scope" | tr "," "\n")
                for func_name in $function_list; do
                    local func_path="/src/core/functions/${func_name}"
                    if [ -f "$func_path" ]; then
                        print_debug "Container: Loading functions from '${func_name}'"
                        source "$func_path"
                    else
                        print_debug "Container: No functions available for '${func_name}'"
                    fi
                done
                ;;
        esac
    else
        # Load all function files by default
        for func_file in /src/core/functions/*; do
            if [ "$func_file" != "/src/core/functions/00-container" ]; then
                print_debug "Container: Loading functions from '${func_file}'"
                source "${func_file}"
            fi
        done
    fi
}

# Retrieves the image version from changelog files based on IMAGE_NAME or IMAGE_REPO_URL.
get_image_version() {
    # Temporarily disable output to prevent unnecessary logging
    output_off

    # Validate if IMAGE_NAME is set
    if [ -n "${IMAGE_NAME}" ]; then
        local image_version=""
        local changelog_paths=(
            "/assets/.changelogs/${IMAGE_NAME/\//_}.md"
            "/assets/.changelogs/docker-${IMAGE_NAME/\//_}.md"
            "/assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md"
        )

        # Iterate over possible changelog paths to find the version
        for changelog in "${changelog_paths[@]}"; do
            if [ -f "${changelog}" ]; then
                image_version=$(head -n1 "${changelog}" | awk '{print $2}')
                break
            fi
        done

        # If no version is found, attempt to retrieve from IMAGE_REPO_URL
        if [ -z "${image_version}" ] && [ -n "${IMAGE_REPO_URL}" ]; then
            local repo_changelog_path
            repo_changelog_path=$(echo "${IMAGE_REPO_URL%/}" | sed "s#https://github.com/##g")
            local repo_changelog="/assets/.changelogs/${repo_changelog_path/\//_}.md"

            if [ -f "${repo_changelog}" ]; then
                image_version=$(head -n1 "${repo_changelog}" | awk '{print $2}')
            fi
        fi

        # Print the image version if retrieved
        if [ -n "${image_version}" ]; then
            echo "${image_version}"
        fi
    fi

    # Re-enable output
    output_on
}

# Converts environment variables ending with '_FILE' into their content values if they point to valid files.
transform_file_var() {
    # Extract and iterate through all provided variables
    local variables
    variables=$(echo "$@" | tr " " "\n")

    for variable in $variables; do
        local file_variable="${variable}_FILE"

        # Check if a corresponding *_FILE variable exists
        if [ -v "${file_variable}" ]; then
            # Validate if the file exists
            if [ ! -f "${!file_variable}" ]; then
                print_error "[transform_file_var] ${file_variable} is set, but the file does not exist."
                return 1
            fi

            # Replace variable value with file content
            export "${variable}"="$(cat "${!file_variable}")"
            print_debug "[transform_file_var] Transformed '${variable}' from file '${!file_variable}'"
        fi
    done

    # Clean up temporary variables
    unset file_variable
    unset variables
}

# -------------------------------
# SYSTEM CONFIGURATION
# -------------------------------
# Functions for managing system-level configurations.
# Grants 'doas' privileges to a specified user for specific commands.
grant_doas() {
    # Temporarily disable output to prevent unwanted logs
    output_off

    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[grant_doas] User is required."
        output_on
        return 1
    fi

    local user="$1"
    local doas_command=""

    print_debug "Adding 'doas' privileges to user: '$user'"

    # Check if a specific command is provided
    if [ -n "$2" ]; then
        doas_command="cmd $2"
        print_debug "Adding 'doas' privileges for command: '$2'"
    fi

    # Append configuration to doas.conf
    echo "permit nopass $user ${doas_command} as root" >> /etc/doas.conf

    # Ensure correct file ownership and permissions
    chown root:root /etc/doas.conf
    chmod 0400 /etc/doas.conf

    print_info "'doas' privileges successfully added for user: '$user'"

    # Re-enable output
    output_on
}

# Grants 'sudo' privileges to a specified user with optional command restrictions.
grant_sudo() {
    # Temporarily disable output to avoid unnecessary logs
    output_off

    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[grant_sudo] User is required."
        output_on
        return 1
    fi

    local user="$1"
    local sudo_command="ALL"

    # If a specific command is provided, set sudo_command
    if [ -n "$2" ]; then
        sudo_command="$2"
        print_debug "Adding 'sudo' privileges to user '$user' for command '$sudo_command'"
    else
        print_debug "Adding 'sudo' privileges to user '$user' for all commands"
    fi

    # Append sudo configuration to /etc/sudoers
    echo "%$user ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers

    # Validate sudoers file syntax
    if ! visudo -c >/dev/null 2>&1; then
        print_error "[grant_sudo] Invalid syntax in /etc/sudoers file. Reverting changes."
        sed -i "\|%$user ALL=(ALL) NOPASSWD:${sudo_command}|d" /etc/sudoers
        output_on
        return 1
    fi

    print_info "'sudo' privileges successfully added for user: '$user'"

    # Re-enable output
    output_on
}

# Sets the system timezone if valid, ensuring proper validation and logging.
set_timezone() {
    # Validate if TIMEZONE variable is set
    if [ -z "${TIMEZONE}" ]; then
        print_error "[set_timezone] TIMEZONE variable is not set."
        return 1
    fi

    local current_timezone
    current_timezone="$(cat /etc/timezone 2>/dev/null || echo "UTC")"

    # Check if the specified timezone exists
    if [ -f "/usr/share/zoneinfo/${TIMEZONE}" ]; then
        if [ "${TIMEZONE}" != "${current_timezone}" ]; then
            print_notice "[set_timezone] Changing timezone from '${current_timezone}' to '${TIMEZONE}'"
            cp -f "/usr/share/zoneinfo/${TIMEZONE}" /etc/localtime
            echo "${TIMEZONE}" > /etc/timezone
            print_info "[set_timezone] Timezone successfully updated to '${TIMEZONE}'"
        else
            print_info "[set_timezone] Timezone is already set to '${TIMEZONE}'"
        fi
    else
        print_warn "[set_timezone] Specified timezone '${TIMEZONE}' does not exist. Retaining current timezone '${current_timezone}'"
    fi
}

# Dynamically updates /etc/hosts with IP and domain mappings from environment variables.
host_override() {
    # Get the number of host overrides defined in environment variables
    local host_count
    host_count=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9]+)')

    # Loop through each host override entry
    for (( i = 1; i <= host_count; i++ )); do
        local host_index
        host_index=$(printf "%02d" "$i") # Format index to two digits

        local host_variable="CONTAINER_HOST_OVERRIDE_${host_index}"
        local host_entry="${!host_variable}" # Retrieve variable value dynamically

        # Extract the IP address and domains from the variable
        local host_ip
        host_ip=$(echo "${host_entry}" | awk '{print $1}')

        # If the host IP is not in valid IPv4 format, resolve it using `getent`
        if [[ ! "${host_ip}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            host_ip=$(getent ahostsv4 "${host_ip}" | grep -m 1 STREAM | awk '{print $1}')
        fi

        # Append the entry to /etc/hosts
        if [ -n "${host_ip}" ]; then
            echo "# Added automatically by ${host_variable}" >> /etc/hosts
            echo "${host_ip} $(echo "${host_entry}" | cut -d' ' -f2-)" >> /etc/hosts
            print_info "[host_override] Added entry: ${host_ip} $(echo "${host_entry}" | cut -d' ' -f2-)"
        else
            print_warn "[host_override] Unable to resolve IP for ${host_variable}"
        fi
    done
}

# Creates a logrotate configuration file for a specified log file with optional settings.
create_logrotate() {
    # Validate required arguments
    if [ -z "$1" ] || [ -z "$2" ]; then
        print_error "[create_logrotate] Logrotate name and log file path are required."
        return 1
    fi

    local config_name="$1"
    local log_path="$2"
    local logship_parser=""
    local user_config=""

    # Check if logrotate configuration already exists
    if [ -f "/assets/logrotate/${config_name}" ]; then
        print_debug "[create_logrotate] Logrotate entry '${config_name}' already exists. Skipping creation."
        return 0
    fi

    print_debug "[create_logrotate] Creating Logrotate Entry for '${log_path}'"

    # Parse optional third argument for logship configuration
    if [ -n "$3" ] && [ "${3,,}" != "none" ]; then
        logship_parser="# logship: $3"
    fi

    # Parse optional user and group for 'su' directive
    if [ -n "$4" ] && [ -n "$5" ]; then
        user_config="    su $4 $5"
    fi

    # Ensure the logrotate directory exists
    mkdir -p /assets/logrotate

    # Create logrotate configuration file
    cat <<EOF > "/assets/logrotate/${config_name}"
${logship_parser}
${log_path} {
    missingok
${user_config}
}
EOF

    # Set appropriate file permissions
    chown root:root "/assets/logrotate/${config_name}"
    chmod 0644 "/assets/logrotate/${config_name}"

    print_info "[create_logrotate] Logrotate entry '${config_name}' created successfully."
}

# Creates a Zabbix configuration file for a specific service with optional autoregister settings.
create_zabbix() {
    # Validate required arguments
    if [ -z "$1" ]; then
        print_error "[create_zabbix] Service name is required."
        return 1
    fi

    # Parse autoregister argument
    local service_name="$1"
    local autoregister="${2:-$1}"

    print_debug "[create_zabbix] Adding Zabbix Auto Register configuration for '${service_name}'"

    # Check if monitoring is enabled and backend is Zabbix
    if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
        if [ -z "${ZABBIX_CONFIG_PATH}" ] || [ -z "${ZABBIX_CONFIG_FILE}" ]; then
            print_error "[create_zabbix] Zabbix configuration path or file is not set."
            return 1
        fi

        # Source Zabbix defaults
        source /src/config/defaults/03-monitoring

        # Ensure the configuration directory exists
        mkdir -p "${ZABBIX_CONFIG_PATH}/${ZABBIX_CONFIG_FILE}.d"

        # Create Zabbix configuration file
        cat <<EOF > "${ZABBIX_CONFIG_PATH}/${ZABBIX_CONFIG_FILE}.d/focela_${service_name}.conf"
# Zabbix ${service_name} Configuration - Automatically Generated
# Autoregister=${autoregister}
EOF

        print_info "[create_zabbix] Zabbix configuration for '${service_name}' created successfully."
    else
        print_warn "[create_zabbix] Monitoring is disabled or backend is not Zabbix. Skipping configuration."
    fi
}

# -------------------------------
# CUSTOM ACTIONS
# -------------------------------
# Functions to handle custom scripts and file operations.
# Copies custom files from a source directory to a destination directory, optionally setting ownership.
custom_files() {
    # Validate and set source and destination directories.
    local source_path="${1:-${CONTAINER_CUSTOM_PATH}}"
    local destination_path="${2}"
    local owner=""

    # If destination path is not provided, set it based on input.
    if [[ -z "${destination_path}" ]]; then
        destination_path="${1}"
        source_path="${CONTAINER_CUSTOM_PATH}"
    fi

    # Check if the source directory exists and is not empty.
    if [[ -d "${source_path}" ]] && dir_notempty "${source_path}"; then
        print_debug "Custom Files: Copying files from '${source_path}' to '${destination_path}'"

        # Ensure the destination directory exists.
        mkdir -p "${destination_path}"

        # Copy files from source to destination.
        cp -aR "${source_path}/" "${destination_path}/"
    else
        print_warn "Custom Files: Source directory '${source_path}' is empty or does not exist."
    fi

    # Set ownership if user and/or group are provided.
    if [[ -n "${3}" && -z "${4}" ]]; then
        owner="${3}"
    elif [[ -n "${3}" && -n "${4}" ]]; then
        owner="${3}:${4}"
    fi

    if [[ -n "${owner}" ]]; then
        chown -R "${owner}" "${destination_path}"
    fi
}

# Runs executable custom scripts from a given or default directory.
custom_scripts() {
    # Define the source directory for custom scripts
    local script_source="${1:-${CONTAINER_CUSTOM_SCRIPTS_PATH}}"

    # Validate if the directory exists and is not empty
    if [ -d "${script_source}" ] && dir_notempty "${script_source}"; then
        print_debug "[custom_scripts] Executing scripts from '${script_source}'"

        # Iterate through all shell scripts in the directory
        for script in "${script_source}"/*.sh; do
            if [ -x "${script}" ] && [ ! -d "${script}" ]; then
                print_debug "[custom_scripts] Executing script: '${script}'"
                "${script}"
            fi
        done
    else
        print_warn "[custom_scripts] No valid scripts found in '${script_source}'"
    fi
}

# -------------------------------
# SANITY CHECKS
# -------------------------------
# Functions to validate environment variables and database readiness.
# Validates database configuration based on the specified database type.
sanity_db() {
    output_off

    # Validate database type argument
    if [[ -z "$1" ]]; then
        print_debug "Using legacy db_ready command - please upgrade"
        legacy_db_check
        output_on
        return
    fi

    local db_type="${1,,}"
    local db_host=""
    local db_user=""
    local db_pass=""
    local db_name=""
    local db_vars=()

    # Common transformation logic
    transform_db_vars() {
        for var in "$@"; do
            transform_file_var "${var}"
            if [[ -n "${!var}" ]]; then
                echo "${!var}"
                return
            fi
        done
    }

    # Process database configuration based on type
    print_debug "Checking ${db_type} Database Parameters"
    case "${db_type}" in
        "couch" | "couchdb")
            db_host=$(transform_db_vars DB_HOST COUCH_HOST)
            [[ -z "${db_host}" ]] && print_error "No CouchDB Host Entered! - Set '\$DB_HOST' or '\$COUCH_HOST'" && exit 1
            ;;

        "influx" | "influxdb")
            db_host=$(transform_db_vars DB_HOST INFLUX_HOST)
            [[ -z "${db_host}" ]] && print_error "No InfluxDB Host Entered! - Set '\$DB_HOST' or '\$INFLUX_HOST'" && exit 1
            ;;

        "mongo" | "mongodb")
            db_host=$(transform_db_vars DB_HOST MONGO_HOST)
            [[ -z "${db_host}" ]] && print_error "No MongoDB Host Entered! - Set '\$DB_HOST' or '\$MONGO_HOST'" && exit 1
            ;;

        "mysql" | "mariadb")
            db_host=$(transform_db_vars DB_HOST MYSQL_HOST MARIA_HOST)
            db_user=$(transform_db_vars DB_USER MYSQL_USER MARIA_USER)
            db_pass=$(transform_db_vars DB_PASS MYSQL_PASS MARIA_PASS)
            db_name=$(transform_db_vars DB_NAME MYSQL_NAME MARIA_NAME)

            [[ -z "${db_host}" ]] && print_error "No MariaDB Host Entered!" && exit 1
            [[ -z "${db_name}" ]] && print_error "No MariaDB Name Entered!" && exit 1
            [[ -z "${db_user}" ]] && print_error "No MariaDB User Entered!" && exit 1
            [[ -z "${db_pass}" ]] && print_error "No MariaDB Password Entered!" && exit 1
            ;;

        "pgsql" | "psql" | "postgres" | "postgresql")
            db_host=$(transform_db_vars DB_HOST POSTGRES_HOST)
            db_user=$(transform_db_vars DB_USER POSTGRES_USER)
            db_pass=$(transform_db_vars DB_PASS PGPASSWORD)
            db_name=$(transform_db_vars DB_NAME POSTGRES_NAME)

            [[ -z "${db_host}" ]] && print_error "No PostgreSQL Host Entered!" && exit 1
            [[ -z "${db_name}" ]] && print_error "No PostgreSQL Name Entered!" && exit 1
            [[ -z "${db_user}" ]] && print_error "No PostgreSQL User Entered!" && exit 1
            [[ -z "${db_pass}" ]] && print_error "No PostgreSQL Password Entered!" && exit 1
            ;;

        "rabbit" | "rabbitmq")
            db_host=$(transform_db_vars DB_HOST RABBIT_HOST RABBITMQ_HOST)
            [[ -z "${db_host}" ]] && print_error "No RabbitMQ Host Entered!" && exit 1
            ;;

        "redis")
            db_host=$(transform_db_vars DB_HOST REDIS_HOST)
            [[ -z "${db_host}" ]] && print_error "No Redis Host Entered!" && exit 1
            ;;

        "rethink")
            db_host=$(transform_db_vars DB_HOST RETHINK_HOST)
            [[ -z "${db_host}" ]] && print_error "No RethinkDB Host Entered!" && exit 1
            ;;

        *)
            print_error "Unsupported database type: ${db_type}"
            exit 1
            ;;
    esac

    print_info "${db_type^} Database parameters validated successfully."
    output_on
}

# Legacy Database Check (for backward compatibility)
legacy_db_check() {
    db_host=$(transform_db_vars DB_HOST)
    db_name=$(transform_db_vars DB_NAME)
    db_user=$(transform_db_vars DB_USER)
    db_pass=$(transform_db_vars DB_PASS)

    [[ -z "${db_host}" ]] && print_error "No Database Host Entered!" && exit 1
    [[ -z "${db_name}" ]] && print_error "No Database Name Entered!" && exit 1
    [[ -z "${db_user}" ]] && print_error "No Database User Entered!" && exit 1
    [[ -z "${db_pass}" ]] && print_error "No Database Password Entered!" && exit 1
}

# Validates a required environment variable, logs an error, and exits if it's missing or empty.
sanity_var() {
    # Disable debug output to avoid unnecessary log clutter.
    output_off

    # Validate if the variable name is provided as the first argument.
    if [ -z "$1" ]; then
        print_error "[sanity_var] Missing environment variable name as argument."
        output_on
        exit 1
    fi

    # Assign variable name and optional description.
    local var_name="$1"
    local var_description="${2:-$1}" # Use var_name as description if not provided.

    # Check if the environment variable is set and non-empty.
    print_debug "[sanity_var] Validating environment variable: '${var_name}'"
    if [ -z "${!var_name}" ]; then
        print_error "[sanity_var] No '${var_description}' provided! Set '\$$var_name'."
        output_on
        exit 1
    fi

    # Log success if the variable exists and is non-empty.
    print_info "[sanity_var] Environment variable '${var_name}' is set."

    # Re-enable debug output.
    output_on
}

# -------------------------------
# WAITING FUNCTIONS
# -------------------------------
# Functions to wait for resources to become available.
# Waits until a specified directory exists before proceeding.
wait_for_directory() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[wait_for_directory] Directory path is required."
        return 1
    fi

    local dir_path="$1"
    local retry_interval=1  # Time interval between retries in seconds

    print_debug "[wait_for_directory] Waiting for directory: '${dir_path}'"

    # Loop until the directory exists
    while [ ! -d "${dir_path}" ]; do
        sleep "${retry_interval}"
        print_debug "[wait_for_directory] Directory '${dir_path}' not found. Retrying in ${retry_interval}s..."
    done

    print_info "[wait_for_directory] Directory '${dir_path}' now exists."
}

# Waits until a specified file exists before continuing execution.
wait_for_file() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[wait_for_file] File path is required."
        return 1
    fi

    local file_path="$1"
    local retry_interval=1  # Time interval between retries in seconds

    print_debug "[wait_for_file] Waiting for file: '${file_path}'"

    # Wait until the file exists
    while [ ! -f "${file_path}" ]; do
        sleep "${retry_interval}"
        print_debug "[wait_for_file] File '${file_path}' not found. Retrying in ${retry_interval}s..."
    done

    print_info "[wait_for_file] File '${file_path}' now exists."
}

# Waits until a host and port are available for connection.
wait_for_port() {
    # Validate input arguments
    if [ -z "$1" ] || [ -z "$2" ]; then
        print_error "[wait_for_port] Host and port are required."
        return 1
    fi

    local host="$1"
    local port="$2"
    local retry_interval=5   # Time interval between retries in seconds
    local timeout=300        # Maximum wait time in seconds
    local counter=0

    print_debug "[wait_for_port] Waiting for '${host}:${port}' to become available."

    # Loop until the port is open or timeout is reached
    while ! (nc -z "${host}" "${port}"); do
        sleep "${retry_interval}"
        ((counter += retry_interval))

        print_warn "[wait_for_port] Host '${host}' is not listening on port '${port}', retrying... (${counter}s elapsed)"

        if [ "${counter}" -ge "${timeout}" ]; then
            print_error "[wait_for_port] Timeout reached. Host '${host}' did not open port '${port}'."
            return 1
        fi
    done

    print_info "[wait_for_port] Host '${host}' is now listening on port '${port}'."
}

# Waits until a specified Unix socket file exists before proceeding.
wait_for_socket() {
    # Validate input arguments
    if [ -z "$1" ]; then
        print_error "[wait_for_socket] Socket path is required."
        return 1
    fi

    local socket_path="$1"
    local retry_interval=1  # Time interval between retries in seconds
    local timeout=300       # Maximum wait time in seconds
    local counter=0

    print_debug "[wait_for_socket] Waiting for socket: '${socket_path}'"

    # Loop until the socket exists or timeout is reached
    while [ ! -S "${socket_path}" ]; do
        sleep "${retry_interval}"
        ((counter += retry_interval))

        print_warn "[wait_for_socket] Socket '${socket_path}' not found. Retrying... (${counter}s elapsed)"

        if [ "${counter}" -ge "${timeout}" ]; then
            print_error "[wait_for_socket] Timeout reached. Socket '${socket_path}' is still unavailable."
            return 1
        fi
    done

    print_info "[wait_for_socket] Socket '${socket_path}' is now available."
}

# -------------------------------
# BOOLEAN HELPERS
# -------------------------------
# Functions to handle boolean values in different formats.
# Converts a boolean-like variable value ('true', 'false', 'yes', 'no') to 'yes' or 'no' with optional case formatting.
truefalse_yesno() {
    # Retrieve the value and variable name from the environment.
    local value var
    value=$(set | grep "^${1}=" | cut -d '=' -f2)
    var=$(set | grep "^${1}=" | sed "s/=.*//g")

    # Validate if the variable exists.
    if [ -z "${var}" ]; then
        print_error "Variable '${1}' not found."
        return 1
    fi

    # Convert 'true' or 'yes' to 'yes'
    if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
        print_debug "Converting variable '${var}' value to 'yes'"
        unset "${1}"
        case "${2,,}" in
            "uppercase" | "upper" | "uc")
                export "${1}=YES"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=yes"
                ;;
            *)
                export "${1}=yes"
                ;;
        esac

    # Convert 'false' or 'no' to 'no'
    elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
        print_debug "Converting variable '${var}' value to 'no'"
        unset "${1}"
        case "${2,,}" in
            "uppercase" | "upper" | "uc")
                export "${1}=NO"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=no"
                ;;
            *)
                export "${1}=no"
                ;;
        esac
    else
        print_warn "Variable '${var}' does not have a recognized boolean value."
    fi
}

# Converts a boolean-like variable value ('true', 'false', 'yes', 'no') to 'ON' or 'OFF' with optional case formatting.
truefalse_onoff() {
    # Validate if the variable exists
    local value var
    value=$(set | grep "^${1}=" | cut -d '=' -f2)
    var=$(set | grep "^${1}=" | sed "s/=.*//g")

    if [ -z "${var}" ]; then
        print_error "Variable '${1}' not found."
        return 1
    fi

    # Handle 'true' and 'yes' values
    if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
        print_debug "Converting variable '${var}' value to 'ON'"
        unset "${1}"
        case "${2,,}" in
            "uppercase" | "upper" | "uc")
                export "${1}=ON"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=on"
                ;;
            *)
                export "${1}=ON"
                ;;
        esac

    # Handle 'false' and 'no' values
    elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
        print_debug "Converting variable '${var}' value to 'OFF'"
        unset "${1}"
        case "${2,,}" in
            "uppercase" | "upper" | "uc")
                export "${1}=OFF"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=off"
                ;;
            *)
                export "${1}=OFF"
                ;;
        esac

    # Handle unrecognized values
    else
        print_warn "Variable '${var}' does not have a recognized boolean value."
    fi
}

# Converts a boolean-like variable value ('true', 'false', 'yes', 'no') to '1' or '0'.
truefalse_onezero() {
    # Validate if the variable exists
    local value var
    value=$(set | grep "^${1}=" | cut -d '=' -f2)
    var=$(set | grep "^${1}=" | sed "s/=.*//g")

    if [ -z "${var}" ]; then
        print_error "Variable '${1}' not found."
        return 1
    fi

    # Handle 'true' and 'yes' values
    if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
        print_debug "Converting variable '${var}' value to '1'"
        unset "${1}"
        export "${1}=1"

    # Handle 'false' and 'no' values
    elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
        print_debug "Converting variable '${var}' value to '0'"
        unset "${1}"
        export "${1}=0"

    # Handle unrecognized values
    else
        print_warn "Variable '${var}' does not have a recognized boolean value."
        return 1
    fi
}

# Converts boolean-like variable values ('yes', 'no', 'true', 'false') to 'TRUE'/'FALSE' or 'true'/'false'.
yesno_truefalse() {
    local value var format

    # Validate if the variable exists
    value=$(set | grep "^${1}=" | cut -d '=' -f2)
    var=$(set | grep "^${1}=" | sed "s/=.*//g")

    if [ -z "${var}" ]; then
        print_error "Variable '${1}' not found."
        return 1
    fi

    # Handle 'true' or 'yes' values
    if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
        print_debug "Converting variable '${var}' value to 'TRUE'"
        unset "${1}"
        format="${2,,}"

        case "${format}" in
            "uppercase" | "upper" | "uc")
                export "${1}=TRUE"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=true"
                ;;
            *)
                export "${1}=TRUE"
                ;;
        esac

    # Handle 'false' or 'no' values
    elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
        print_debug "Converting variable '${var}' value to 'FALSE'"
        unset "${1}"
        format="${2,,}"

        case "${format}" in
            "uppercase" | "upper" | "uc")
                export "${1}=FALSE"
                ;;
            "lowercase" | "lower" | "lc")
                export "${1}=false"
                ;;
            *)
                export "${1}=FALSE"
                ;;
        esac

    # Handle unrecognized values
    else
        print_warn "Variable '${var}' does not have a recognized boolean value."
        return 1
    fi
}

# Checks if the given variable value is 'false' or 'no' (case-insensitive).
var_false() {
    local value="${1,,}"  # Convert the input value to lowercase

    if [[ "${value}" == "false" || "${value}" == "no" ]]; then
        return 0  # True (0) if the value matches 'false' or 'no'
    else
        return 1  # False (1) otherwise
    fi
}

# Checks if the given variable value is not 'false' (case-insensitive).
var_notfalse() {
    local value="${1,,}"  # Convert the input value to lowercase

    if [[ "${value}" != "false" ]]; then
        return 0  # True (0) if the value is not 'false'
    else
        return 1  # False (1) if the value is 'false'
    fi
}

# Checks if the given variable value is 'true' or 'yes' (case-insensitive).
var_true() {
    local value="${1,,}"  # Convert the input value to lowercase

    if [[ "${value}" == "true" || "${value}" == "yes" ]]; then
        return 0  # True (0) if the value is 'true' or 'yes'
    else
        return 1  # False (1) otherwise
    fi
}

# Checks if the given variable value is not 'true' (case-insensitive).
var_nottrue() {
    local value="${1,,}"  # Convert the input value to lowercase

    if [[ "${value}" != "true" ]]; then
        return 0  # True (0) if the value is not 'true'
    else
        return 1  # False (1) if the value is 'true'
    fi
}

# -------------------------------
# Debug Mode Configuration
# -------------------------------
# Enables or disables debug mode based on the DEBUG_MODE variable.
case "${DEBUG_MODE,,}" in
    "TRUE" | "true" | "YES" | "yes" | "ON" | "on")
        # Enable global debug mode
        CONTAINER_LOG_LEVEL="DEBUG"
        set -x
        ;;

    "FALSE" | "false" | "NO" | "no" | "OFF" | "off")
        # Disable debug mode explicitly (No action needed here)
        :
        ;;

    *)
        # Enable debug mode for specific scripts based on the directory
        script_dir="$(dirname "$0")"

        if [[ "${script_dir}" == "/var/run/s6/etc/cont-init.d" || "${script_dir}" == "/etc/cont-init.d" ]]; then
            if [[ "${DEBUG_MODE}" == "$(basename "$0")" ]]; then
                print_notice "Enabling Debug mode for $(basename "$0") scripts"
                set -x
            fi
        fi

        # Enable debug mode for specific directories
        if [[ "${DEBUG_MODE}" == "$(basename "$PWD")" ]]; then
            print_notice "Enabling Debug mode for $(basename "$PWD") scripts"
            set -x
        fi
        ;;
esac
