#!/command/with-contenv bash

# -------------------------------------------------
# Container Core Functions Script
# -------------------------------------------------
# This script defines core functions for container initialization,
# service management, and utility operations.

# -------------------------------
# Import Defaults
# -------------------------------
# Load default container configuration variables.
source /src/config/defaults/00-container

# -------------------------------
# Color Configuration
# -------------------------------
# Define background colors for terminal outputs.
bdg="\e[42m"       # Dark Green
bdb="\e[44m"       # Dark Blue
bdm="\e[45m"       # Dark Magenta
bdgy="\e[100m"     # Dark Gray
blr="\e[101m"      # Light Red
boff="\e[49m"      # Reset Background Color

# -------------------------------
# Initialization Checks
# -------------------------------
# Check if the container initialization scripts have completed.
check_container_initialized() {
    print_debug "Checking if container initialization scripts have completed"

    # Disable output to avoid cluttering logs.
    output_off

    # Loop until the initialization flag file is present.
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Container initialization scripts not yet completed, retrying..."
        sleep 1
    done

    # Re-enable output after initialization is confirmed.
    output_on
}

# Check if a specific service within the container has been initialized.
check_service_initialized() {
    print_debug "Checking if service has been initialized"

    # Disable output to avoid cluttering logs.
    output_off

    # Determine the service suffix and bypass flag based on input arguments.
    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    # Determine the service name if bypass is disabled.
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    # Wait until the service initialization flag file is present.
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        print_debug "Waiting for service initialization: /tmp/.container/${service}${service_suffix}"
        sleep 1
    done

    # Clean up temporary variables.
    unset csi_bypass

    # Re-enable output after initialization is confirmed.
    output_on
}

# -------------------------------------------------
# Repository Management
# -------------------------------------------------
# This function clones a Git repository to a specified location
# with optional branch/tag and directory support.
clone_git_repo() {
    # Disable debug mode temporarily to avoid unnecessary log clutter.
    set +x
    if [ "${DEBUG_MODE,,}" = "true" ]; then set -x; fi

    # Check if Git is installed.
    if ! command -v git > /dev/null; then
        echo "[clone_git_repo] Git is not installed."
        exit 1
    fi

    # Configure Git to use the default branch as "main".
    git config --global init.defaultBranch main

    # Validate and process input arguments.
    if [ -n "$1" ]; then
        local repo
        local repo_name
        local repo_commit
        local repo_text=""
        local append_git_prefix=""

        # Determine repository target directory.
        if [ -n "$3" ]; then
            repo="$3/"
            repo_text="to '${3}'"
        else
            repo="/usr/src/$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        # Generate a sanitized repository name.
        repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"

        # Export environment variables for the repository.
        export GIT_REPO_SRC="${repo}"
        export GIT_REPO_SRC_${repo_name^^}="${repo}"

        # Check if the target directory already exists.
        if [ -d "${repo}" ]; then
            echo "[clone_git_repo] Directory ${repo} already exists. Cannot clone."
            exit 1
        fi

        # Append ".git" suffix if not present.
        if [[ $1 != *".git" ]]; then
            append_git_prefix=".git"
        fi

        # Clone the repository.
        mkdir -p "${repo}"
        cd "${repo}" || exit 1
        git init .
        git remote add origin "${1}${append_git_prefix}"

        if [ -n "$2" ]; then
            repo_commit="$2"
        fi

        echo "[clone_git_repo] Cloning Git Repo '${1}' '${repo_commit}' ${repo_text}"
        git fetch --depth=1 origin "${repo_commit}" +refs/tags/*:refs/tags/*
        git fetch --depth=1 origin "${repo_commit}"
        git -c advice.detachedHead=false checkout FETCH_HEAD
        git submodule update --init
    else
        echo "[clone_git_repo] No arguments provided to the function."
        exit 1
    fi

    # Re-enable debug mode if it was initially enabled.
    set -x
}

# Install a configuration template to a destination path.
install_template() {
    # Validate required arguments
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        print_error "[install_template] Missing required arguments."
        exit 1
    fi

    # Assign arguments to local variables
    local user="$1"
    local source_file="$2"
    local destination_file="$3"
    local template_mode="${4:-0644}"

    # Check if the source file exists
    if [ ! -f "$source_file" ]; then
        print_error "[install_template] Source file not found: $source_file"
        exit 1
    fi

    # Create destination directory if it does not exist
    if [ ! -d "$(dirname "$destination_file")" ]; then
        mkdir -p "$(dirname "$destination_file")"
    fi

    # Copy the template to the destination
    cp "$source_file" "$destination_file"

    # Set file permissions
    chmod "$template_mode" "$destination_file"

    # Set file ownership
    chown "$user" "$destination_file"

    # Print success message
    print_info "[install_template] Template installed successfully to $destination_file"
}

# Updates template files by replacing placeholders with environment variable values.
update_template() {
    # Validate required arguments
    if [ -z "$1" ]; then
        print_error "[update_template] No template files provided."
        return 1
    fi

    # Parse arguments
    local template_files="$1"
    shift
    local template_variables=("$@")

    # Process each template file
    for template_file in $(echo "${template_files}" | tr " " "\n"); do
        # Check if the template file exists
        if [ ! -f "${template_file}" ]; then
            print_error "[update_template] Template file not found: ${template_file}"
            return 1
        fi

        # Gather template metadata
        local template_user
        template_user=$(stat -c %U "${template_file}")
        local template_tmp_file
        template_tmp_file=$(mktemp)

        # Copy the template to a temporary file
        cp -a "${template_file}" "${template_tmp_file}"

        # Replace placeholders in the temporary template file
        for template_variable in "${template_variables[@]}"; do
            # Maintain compatibility: {{VAR}} -> ${VAR}
            sed -ri "s/[{]{2}${template_variable}[}]{2}/\${${template_variable}}/g" "${template_tmp_file}"
            print_debug "[update_template] Updating '${template_file}' with variable '${template_variable}'"
        done

        # Replace placeholders with actual variable values
        (
            export "${template_variables[@]}"
            local IFS=":"
            sudo -HEu "${template_user}" envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )

        # Clean up temporary file
        rm -f "${template_tmp_file}"

        print_info "[update_template] Template updated successfully: ${template_file}"
    done
}

# -------------------------------
# Logging and Debugging
# -------------------------------
# Generates a formatted log prefix with date and time.
log_prefix() {
    # Disable output to prevent unwanted logs during prefix generation
    output_off

    # Check if log prefix is enabled
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        local current_date
        local current_time
        local prefix_separator="${CONTAINER_LOG_PREFIX_SEPERATOR}"

        # Generate formatted date and time strings
        current_date=$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")
        current_time=$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}")

        # Output the log prefix
        echo "${current_date}${prefix_separator}${current_time} "
    fi

    # Re-enable output after prefix generation
    output_on
}

# Print debug messages to the console and/or log file if enabled.
print_debug() {
    # Disable output temporarily to prevent unwanted clutter
    output_off

    # Check if debug logging is enabled for console output
    if [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
        local log_message="$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        local log_message_colorized="$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if debug logging is enabled for log files
    if [ "${CONTAINER_LOG_FILE_LEVEL,,}" = "debug" ]; then
        echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs error messages to the console and/or log file based on configuration settings.
print_error() {
    # Disable output temporarily to avoid unwanted log clutter
    output_off

        local log_message
    local log_message_colorized

    # Prepare the log messages for plain and colored output
    log_message="$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if console error logging is enabled based on log level
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Check if file error logging is enabled based on file log level
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn|error)$ ]]; then
        echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs informational messages to the console and/or log file.
print_info() {
    # Temporarily disable output to avoid unwanted log clutter
    output_off

    # Prepare log messages for plain and colorized output
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Check if debug mode is enabled for console output
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
        fi
    fi

    # Always log the message into the log file
    echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"

    # Re-enable output after processing
    output_on
}

# Logs notice messages to the console and/or log file based on configuration settings.
print_notice() {
    # Temporarily disable output to prevent unnecessary clutter in logs
    output_off

    local log_message
    local log_message_colorized

    # Prepare log messages for plain and colorized outputs
    log_message="$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log level is set to debug or notice
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs service startup details, manages process counters, and handles runaway protection.
print_start() {
    # Disable output temporarily to prevent log clutter
    output_off

    local proc_start_count=1
    local proc_start_wrapper=""
    local proc_help_arg=""
    local SHOW_OUTPUT="FALSE"

    # Process Counter Handling
    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ]; then
        if [ -f "/tmp/.container/$(basename "$PWD")" ]; then
            proc_start_count=$(wc -l < "/tmp/.container/$(basename "$PWD")")
            proc_start_wrapper="[${proc_start_count}] "
        fi

        proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$PWD") ${proc_start_count} $(cat /etc/hostname)"

        # Run helper script if available
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/$(basename "$0").sh" "${proc_help_arg}"
            elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" "${proc_help_arg}"
            fi
        fi

        # Runaway Protection
        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ]; then
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ] && [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                SHOW_OUTPUT="TRUE"
            fi

            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                print_error "POTENTIAL RUNAWAY DETECTED: Disabling $(basename "$PWD") service after ${CONTAINER_PROCESS_RUNAWAY_LIMIT} restarts."
                s6-svc -d "/var/run/s6/legacy-services/$(basename "$PWD")"
                sleep 3
                exit 1
            fi

            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ]; then
                sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"
            fi
        fi
    fi

    # Logging Startup Information
    local log_message
    local log_message_colorized

    log_message="$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    log_message_colorized="$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"

    if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "${log_message}"
        else
            echo -e "${log_message_colorized}"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}

# Logs warning messages to the console and/or log file based on configuration settings.
print_warn() {
    # Temporarily disable output to prevent unwanted clutter
    output_off

    local log_message
    local log_message_colorized

    # Prepare plain and colorized log messages
    log_message="$(log_prefix)[WARN] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    log_message_colorized="$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"

    # Log to console if the log level allows warning messages
    if [[ "${CONTAINER_LOG_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "${log_message}"
            else
                echo -e "${log_message_colorized}"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
            else
                echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
            fi
        fi
    fi

    # Log to file if the log file level allows warning messages
    if [[ "${CONTAINER_LOG_FILE_LEVEL,,}" =~ ^(debug|notice|warn)$ ]]; then
        echo -e "${log_message}" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable output after processing
    output_on
}
